# ABSTRACT: What Pinto is, and how to use it
# PODNAME: Pinto::Manual

#------------------------------------------------------------------------------

# VERSION

#------------------------------------------------------------------------------

=head1 DESCRIPTION

This document is an overview of the L<Pinto> tool suite, and a general
guide for using L<Pinto> in the real world.  It is a work-in-progress,
so feel free to send suggestions to the author.

=head1 GOALS

Pinto has two primary goals.  First, Pinto seeks to address the
problem of instability in the CPAN mirrors.  Distribution archives are
constantly added and removed from the CPAN, so if you use it to build
a system or application, you may not get the same result twice.
Second, Pinto seeks to enable developers to use the CPAN toolchain for
building, testing, and dependency management of their own local
software, even if they never plan to release it to the CPAN.

Pinto accomplishes these goals by providing a suite of tools for
creating and managing your own custom repositories of distribution
archives.  These repositories can contain any distribution archives
you like, and can be used with the standard CPAN toolchain.

=head1 PRIOR ART

The idea of a custom repository is not new.  Randal Schwartz presented
L<the idea|http://www.stonehenge.com/merlyn/LinuxMag/col42.html> back
in 2002.  Subsequently, modules like L<CPAN::Site> and L<CPAN::Mini>
were released.  More recently, L<OrePAN> and L<MyCPAN::App::DPAN> have
emerged as well.

Over the last few years, I personally used various combinations of
those modules to create custom repositories at several organizations.
But they always required some wrapping and/or glue to make them usable
in the development cycle.  And none of them seemed to be designed for
extension.

I wanted a suite of tools that would work out-of-the-box, and would
accommodate a fairly wide range of use cases. Hence, L<Pinto> was
born.

=head1 COMPONENTS

The L<Pinto> suite consists of a core set of libraries and three
command line utilities.  Each of these utilities ships in a separate
distribution, so you don't have to install the whole kit if you're
only going to use a subset of the L<Pinto> suite.  However, you can
install L<Task::Pinto> if you'd like to get everything in one shot.

=head1 pinto-admin

L<pinto-admin> is a utility for creating and managing a Pinto
repository.  It supports the core operations of adding local
distribution archives and pulling archives from other repositories.
It also provides reports about the repository and its contents.

=head2 pinto-server

L<pinto-server> provides a web service interface to your Pinto
repository.  This allows multiple (possibly remote) developers to
manage a central repository.  L<pinto-server> also functions as the
backend server to installer clients like L<cpan>, L<cpanp>, and
L<cpanm>.

=head2 pinto-remote

L<pinto-remote> is a utility for interacting with a remote Pinto
repository (via L<pinto-server>).  It supports most of the
operations supported by L<pinto-admin>.


=head1 TERMINOLOGY

Before going any further, I should stop and spell out the terminology
that I'm going to use.

=over 4

=item  Archive

An "archive" is the file that developers ship, which contains all
their application/library code, test cases, build scripts etc.
Converserly, the archive is the file that users must fetch to install
the application/library.  Sometimes I also refer to these as
"distributions".

=item Package

A "package" is something inside a distribution archive that provides
some unit of functionality.  In Perl, packages are declared with the
C<package> keyword.  Some folks call these "modules" but I try to
avoid that term because it is overloaded.

=item Prerequisite

A "prerequisite" is a package that must be installed for the sake of
another distribution archive.  Sometimes I call these "dependencies".

=back

=head1 CONCEPTS

=over4

=item Stack

All CPAN-like repositories have an index which maps the latest
version of each package to the archive that contains it.  But usually,
there is only one such index.  With Pinto, there can be many
indexes.  Each of


=item Pin


dependencies, you can run the mirror command again (it will be much
faster now).  But let's suppose that the new C<Foo-2.0> package breaks
your application.  You can remove its distribution by using the
C<remove> command like so:

  $> pinto-admin -r /my/cpan remove A/AU/AUTHOR/Foo-2.0.tar.gz

Now, when you build your dependency stack, you'll get C<Foo-1.0> (or
whatever version you had before), and all your other dependencies will
be the latest ones available.

=head2 UPGRADING SELECTED PACKAGES

Suppose you just want to upgrade package L<Bar> to version 3.0, which
was just released to the CPAN.  You can do that with the C<import>
command like this:

  $> pinto-admin -r /my/cpan import Bar-3.0

This will bring version 3.0 of package L<Bar> into your repository,
plus any additional dependencies that it requires.

=head2 ADDING YOUR OWN DISTRIBUTIONS

If you package your application into one or more CPAN-style
distributions, then you can also put your own code in the L<Pinto>
repository with the C<add> command:

  $> pinto-admin -r /my/cpan add /path/to/My-Dist-1.4.tar.gz

L<Pinto> will index your distribution (just like PAUSE) and add it to
the repository.  By default, L<Pinto> will also C<import> all the
dependencies that you've declared in your distribution.

Once again, you can point your installer client at F</my/cpan> to
install your distribution, and it will unwind and install all the
dependencies for you, using the L<Pinto> repository as the source.

=head2 PATCHING A CPAN DISTRIBUTION

Let's suppose that your application depends on L<Plack>, and you've
found a critical bug in it.  For whatever reason, the author of Plack
can't or won't fix the bug and you decide to patch the code yourself.
So after you've downloaded the distribution (or perhaps made a copy of
the one in your repository), patched the code and packaged it back up,
you can add it to your repository with the C<add> command:

  $> pinto-admin -r /my/cpan add ~/tmp/Plack-0.89-PATCHED.tar.gz

This is called adding a "local" distribution.  The packages in a local
distribution are always considered newer than the same package in a
"foreign" distribution.  So when clients request the "Plack" package
from your repository, they will always get your patched version, even
if the repository contains a foreign version with a higher version
number.

Eventually, the author of Plack finally fixes that bug and releases a
new distribution.  You can pull that distribution into your repository
(and the latest version of all the other distributions) by running the
C<mirror> command.  Finally, you can remove your patched version with
the C<remove> command:

  $> pinto-admin -r /my/cpan remove Plack-0.89-PATCHED.tar.gz

Clients requesting the "Plack" package will no longer get your patched
version, but will get the latest version that was pulled from the CPAN
instead.

=head1 PINTO AND THE DEVELOPMENT CYCLE

Even though *the* CPAN has been around for many years, the concept of
using CPAN-like infrastructure for private development is still
relatively novel.  So for many folks (including me), it isn't
immediately clear how to incorporate Pinto with the development cycle.

The following describes several usage scenarios for Pinto.  Some come
from my own experience, but some are just theoretical.  If you are
using Pinto (or some other variety of private CPAN) in other ways,
please let me know so that I can document it here.

=head2 USAGE STRATEGIES

Given the above use cases, I see four basic strategies for using
L<Pinto>, although I'm sure folks will probably come up with others...

=head3 Local Distributions Only

The first strategy is to use Pinto purely as a repository for local
distributions.  These distributions could be private or public, or a
mix of both.  But the repository contains only the distributions that
you explicitly add to it.

=head3 Project-specific Repository

The fourth (and probably most useful) strategy is to start with an
empty Pinto repository and organically C<add> your local distributions
and C<import> their dependencies as the project evolves over time.  This
keeps your repository small and focused.

=head1 PINTO AND TEAMS

=head1 PINTO AND DEPLOYMENT

=head1 PINTO AND VERSION CONTROL SYSTEMS

One of the major motivations behind Pinto was to integrate with
version control systems (VCS).  Changing dependencies are a frequent
cause of application failure (either in development or, gasp, in
production).  So it is natural to want a mechanism to rollback your
dependencies to a "known-good-state".  This is a natural fit for VCS.

L<Pinto> integrates with VCS by committing (and optionally tagging)
changes to your repository.  L<Pinto> does not provide any direct
mechanism for branching/merging/reverting your VCS.  Nor does L<Pinto>
know which revision of your repository is the "right" one.  It is
still up to you to figure that out.  But since everything L<Pinto>
does is always in your VCS, you should have everything you need to
solve those problems.

=head1 PINTO AND OTHER PACKAGING SYSTEMS

=head1 PINTO AND OTHER CPAN TOOLS

=head1 EXTENDING PINTO

=head1 FUTURE PLANS

=cut
