# ABSTRACT: What Pinto is, and how to use it
# PODNAME: Pinto::Manual

#------------------------------------------------------------------------------

# VERSION

#------------------------------------------------------------------------------

=head1 DESCRIPTION

This document is an overview of the L<Pinto> tool suite, and a general
guide for using L<Pinto> in the real world.  It is a work-in-progress,
so feel free to send suggestions to the author.

=head1 GOALS

Pinto has two primary goals.  First, Pinto seeks to address the
problem of instability in the CPAN mirrors.  Distributions are
constantly added and removed from the CPAN, so if you use it to build
a system or application, you may not get the same result twice.
Second, Pinto seeks to encourage developers to use the CPAN toolchain
for building, testing, and dependency managment of their own software,
even if they never plan to release it to the CPAN.

Pinto accomplishes these goals by providing a suite of tools for
creating and managing private CPAN-like repositories.  These
repositories can contain any distributions you like, and can be used
with the standard CPAN toolchain.

=head1 PRIOR ART

The idea of a private CPAN is not new.  Randal Schwartz discussed the
idea back in XXXX.  Subsequently, modules like L<CPAN::Site> and
L<CPAN::Mini> were released.  More recently, L<OrePAN> and L<MyCPAN>
have emerged as well.

Over the last few years, I acutally used various combinations of those
modules to create private CPAN repositories at several organizations.
But they always required some wrapping and/or glue to make them usable
in the development cycle.  And none of them seemed to be designed for
extension.

I wanted a suite of tools that would work out-of-the-box, and would
accommodate a fairly wide range of use cases. Hence, L<Pinto> was
born.

=head1

=head1 COMPONENTS

The L<Pinto> suite consists of a core set of libraries and three
command line utilities.  Each of these utilities ships in a separate
distribution, so you don't have to install the whole kit if you're
only going to use a subset of the L<Pinto> suite.  However, you can
install L<Task::Pinto> if you'd like to get everything in one shot.

=head1 pinto-admin

L<pinto-admin> is a utility for creating and managing a Pinto
repository.  It supports the core operations of adding and removing
local distributions, as well as mirroring and importing foreign
distributions from other repositories.

=head2 pinto-server

L<pinto-server> provides a web service interface to your Pinto
repository.  This allows multiple (possibly remote) developers to add
or remove distributions to or from a central repository.

=head2 pinto-remote

L<pinto-remote> is a utility for interacting with a remote Pinto
repository (via L<pinto-server>).  It provides a subset of the
operations supported by L<pinto-admin>.


=head1 USE CASES

All use cases revolve around the basic functions of adding and
removing distributions from the repository, but there are differences
in how you select and obtain those distributions.  I have used Pinto
(or can imagine using it) in the following scenarios:

=head1 SNAPSHOT OF CPAN MIRROR

You can use Pinto to create a stable snapshot of a CPAN mirror.  This
can easily be done with the C<mirror> command.

  $> pinto-admin -r /my/cpan create
  $> pinto-admin -r /my/cpan mirror

This creates a repository that contains the latest versions of all
packages on the CPAN (this may take several hours).  Now, when you
point your cpan client (e.g L<cpan>, L<cpanp>, or L<cpanm>) at
F</my/cpan> you can now build your dependency stack and get the same
result over and over.

=head1 UPGRADING A SNAPSHOT

Any time you want to upgrade to the latest version of all your
dependencies, you can run the mirror command again (it will be much
faster now).  But let's suppose that the new C<Foo-2.0> package breaks
your application.  You can remove its distribution by using the
C<remove> command like so:

  $> pinto-admin -r /my/cpan remove A/AU/AUTHOR/Foo-2.0.tar.gz

Now, when you build your dependency stack, you'll get C<Foo-1.0> (or
whatever version you had before), and all your other dependencies will
be the latest ones available.

=head1 PATCHING A CPAN DISTRIBUTION

Let's suppose that your application depends on L<Plack>, and you've
found a critical bug in it.  For whatever reason, the author of Plack
can't or won't fix the bug and you decide to patch the code yourself.
So after you've downloaded the distribution (or perhaps made a copy of
the one in your repostory), patched the code and packaged it back up,
you can add it to your repository with the C<add> command:

  $> pinto-admin -r /my/cpan add ~/tmp/Plack-0.89-PATCHED.tar.gz

This is called adding a "local" distribution.  The packages in a local
distribution are always considered newer than the same package in a
"foreign" distribution.  So when clients requiest the "Plack" package
from your repository, they will always get your patched version, even
if the repository contains a foreign version with a higher version
number.

Eventually, the author of Plack finally fixes that bug and releases a
new distribution.  You can pull that distribution into your repository
(and the latest version of all the other distributions) by running the
C<mirror> command.  Finally, you can remove your patched version with
the C<remove> command:

  $> pinto-admin -r /my/cpan remove Plack-0.89-PATCHED.tar.gz

Clients requesting the "Plack" package will no longer get your patched
version, but will get the latest version that was pulled from the
CPAN instead.

=head1 PRIVATE REPOSITORY

You can also use Pinto to create a repository that 

=head1 PROJECT REPOSITORY

=head1 HYBRID REPOSITORY

=head1 PINTO AND THE DEVELOPMENT CYCLE

Even though *the* CPAN has been around for many years, the concept of
using CPAN-like infrastructure for private development is still
relatively novel.  So for many folks (including me), it isn't
immediately clear how to incorporate Pinto with the development cycle.

The following describes several usage scenarios for Pinto.  Some come
from my own experience, but some are just theoretical.  If you are
using Pinto (or some other variety of private CPAN) in other ways,
please let me know so that I can document it here.

=head2 USAGE STRATEGIES

There are three general strategies for using a Pinto repository.  From
these strategies, I've identified several specific scenarios where
they can be applied.

The first strategy is to use Pinto purely as a repository for local
distributions.  These distributions could be private or public, or a
mix of both.  But the repository contains only the distributions that
you explicitly add to it.

The second strategy is to use Pinto as snapshot of the public CPAN.
In this strategy, your repository contains the current version of
every package indexed on a public CPAN, as-of the time you made the
snapshot.  You may choose to periodically update the snapshot.

The third (and probably most useful) strategy is to combine a snapshot
of the public CPAN with your own local distributions.  In this
scenario, your Pinto repository contains all of the CPAN distributions
plus your local ones, and your local ones always take precedence over
those you got from the public CPAN.

=over 4

=item A Local Patch of a Public CPAN Module

=item A Big Pile of Random CPAN Modules

=item Just My Own Private Distributions

=item Upgrading CPAN Dependencies Over Time

=item Sharing Distributions Across the Organization

=item Managing System-Wide Dependencies

=item Managing Application-Specific Dependencies

=back

=head2 Solo Development

=head2 Team Development

=head1 PINTO AND DEPLOYMENT

=head1 PINTO AND VERSION CONTROL SYSTEMS

One of the major motivations behind Pinto was to integrate with
version control systems (VCS).  Changing dependencies are a frequent
cause of application failure (either in development or, gasp, in
production).  So it is natural to want a mechanism to rollback your
dependencies to a "known-good-state".  This is a natural fit for VCS.

L<Pinto> integrates with VCS by committing (and optionally tagging)
changes to your repository.  L<Pinto> does not provide any direct
mechanism for branching/merging/reverting your VCS.  Nor does L<Pinto>
know which revision of your repository is the "right" one.  It is
still up to you to figure that out.  But since everything L<Pinto>
does is always in your VCS, you should have everything you need to
solve those problems.

=head1 PINTO AND OTHER PACKAGING SYSTEMS

=head1 PINTO AND OTHER CPAN TOOLS

=head1 EXTENDING PINTO

=head1 FUTURE PLANS

=cut
